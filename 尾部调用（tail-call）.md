# 尾部调用扩展（TCE）

## 介绍

### 动机

* 当前，Wasm设计明确禁止尾递归优化。

* 想令其支持，以实现
  - 正确有效地实现需要消除尾部调用的语言
  - 可以用它实现的控件构造的编译(例如，coroutines，continuations)
  - 需要它的编译和优化技术 (例如，动态重新编译，追踪，CPS)
  - 其他类型的被表示为Wasm函数的计算，例如，FSM


### 语义

概念上，尾部调用一个函数，在实际执行之前会释放当前调用栈帧。
这可以应用于任何形式的调用，即:

* 调用者与被调者可以不同
* 调用者与被调者的类型可以不同
* 调用者可以是动态的(例如，`call_indirect`)


## 设计空间

### 指令

* 尾部调用通过单独的显式调用指令执行(已有的调用指令明确不允许TCE)

* 因此，本提案引入了每个call指令的尾部版本

* 另一种方案是引入一个适用于每个调用指令的指令前缀，但被委员会拒绝了
  - WebAssembly将来可能会得到更多的调用指令，例如，`call_ref`
  - 作为修饰符的指令前缀只用在wasm里


### 执行

* 尾部调用的行为类似于`return`和相应的调用的组合

* 因此，它们像`return`那样展开操作数堆栈

* 只保留必要的调用参数

* 对宿主函数的尾部调用不能保证尾部行为(这超出规范范围)


### 类型

* 尾部调用指令的类型规则是由其调用和返回规则合并决定的

* 因为尾部调用传递控制权和展开堆栈，所以它们是栈多态的

* 先前未解决的问题: 尾部调用是否应该产生不同的函数类型? 可能性:
  1. 按类型区分被尾部调用者
  2. 按类型区分尾部调用者
  3. 都是
  4. 都不是

* 考虑:
  - 选项1(和3)允许对不可尾部调用函数使用不同的调用约定，这可能会减少对ABI的限制。
  - 反之，它创建了一个分叉的函数空间，这可能会导致困难，例如在使用函数表或其他形式的动态间接寻址时。
  - 选项2(和3)的优点不明朗。
  - 实验验证表明，选项1也没有显著的性能优势。

* CG解决方案是方案4，因为它最简单。


## 例子

尾递归阶乘函数的一个简单的例子。
```
(func $fac (param $x i64) (result i64)
  (return_call $fac-aux (get_local $x) (i64.const 1))
)

(func $fac-aux (param $x i64) (param $r i64) (result i64)
  (if (i64.eqz (get_local $x))
    (then (return (get_local $r)))
    (else
      (return_call $fac-aux
        (i64.sub (get_local $x) (i64.const 1))
        (i64.mul (get_local $x) (get_local $r))
      )
    )
  )
)

```


## 规范修改

### 结构

新增两条指令:

* `return_call <funcidx>`，`call`的尾部调用版
* `return_call_indirect <tableidx> <typeidx>`，`call_indirect`的尾部调用版

其他的语言扩展例如[带类型函数引用](https://github.com/WebAssembly/function-references/blob/master/proposals/function-references/Overview.md)中引入的新调用指令也会有相应的尾部调用版本。


### 验证

新指令的验证只是`return`和基本调用指令规则的组合(因此它是栈多态的)。

* 如果`x`是函数类型\[t1\*\] -> \[t2\*\],
  则指令`return_call x`有类型\[t3\* t1\*\] -> \[t4\*\],
  对所有t3\*和t4\*,
  假设当前函数具有返回类型\[t2\*\].

* 如果`x`是函数类型\[t1\*\] -> \[t2\*\],
  则指令`return_call_indirect x`有类型\[t3\* t1\* i32\] -> \[t4\*\],
  对所有t3\*和t4\*,
  假设当前函数具有返回类型\[t2\*\].

注意，调用者和被调者的参数类型不必匹配。


### 执行

新指令的执行语义为

1. 弹出调用操作数
2. 清除并弹出顶部栈帧，和`return`一样
3. 操作数重新入栈
4. 委托给相应的纯调用指令


### 二进制格式

在现有的调用指令之后使用保留的操作码，例如:

* `return_call`为0x12
* `return_call_indirect`为0x13


### 文本格式

文本格式以明显的方式扩展了两个新的指令。


## 开放问题

* 跨模块边界的尾部调用能保证尾部行为吗？
