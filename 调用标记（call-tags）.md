# 调用标记提案

(作为历史参考，调用标记曾经被称为[*dispatch* tags](https://github.com/WebAssembly/design/issues/1346).)

## 概述

提供一种方法去新增和调用无类型函数(`funcref`)，以实现:
* 有效率的调用 (和有类型函数调用相比仅多了一个额外的push，pop,和bitwise等效检查)
* 模块可以限制如何间接调用它们的函数(例如，确保没有其他模块可以间接调用特定函数)
* 类型抽象和子类型被尊重

此外，在某些情况下，引擎可以保证间接调用必须位于同一个模块实例中(如果可以的话)，支持各种优化。

`func_switch`扩展增加了高效使用同一个`funcref`来支持多种调用的能力，包括具有不同类型参数甚至不同数量的参数和结果的调用。

## 问题

`call_indirect`带来了许多挑战(下面将详细讨论)，当前以及WebAssembly可能如何发展:
1. 只看函数的定义，一个函数是否可以通过`call_indirect`被间接调用并不明显。
我们必须做一些分析，以检查是否引用了该函数。
一旦函数引用完成，即使是像函数这样简单的东西也很难保证只有它自己的模块才能访问它.
这使得优化函数或确保以模块预期的方式访问它们变得困难。
2. 如果添加了子类型，间接调用方提供的签名可以与被调用方函数的签名兼容，而不必完全相同。
不幸的是，在运行时对签名进行结构比较可能过于昂贵。
[WebAssembly/function-references#33](https://github.com/WebAssembly/function-references/pull/33)
通过要求签名完全匹配来解决这个问题，但是使用子类型的语言的实现者已经指出这样的限制并不适合他们的需要
(例如，Kotlin中的子类可以优化超类方法的签名)。
3. 为了切实支持类型的导入和导出，`call_indirect`需要使用导入/导出类型的"运行时值"比较调用方和被调用方签名。
这可以用来将导入/导出的类型转换为它们应该抽象的类型。
因此`call_indirect`可用于访问本应隐藏在抽象类型后面的信息，或者创建不可伪造的抽象类型的值。

## 方案

一个实现`call_indirect`的办法是将所有参数推送到堆栈上，然后将签名描述符推送到堆栈上;
然后被调用者弹出该描述符，并将其与被调用者自己的签名描述符（按位）进行相等性比较.
如果两者匹配，则由检查器保证的函数具有所需的静态参数(调用者对函数的返回值的要求也一样)，所以函数调用得到处理。
如果两者不匹配，则陷入。
(SpiderMonkey现在就是这样实现`call_indirect`的。)

我们可以通过*调用标记*解决以上所有问题。
换句话说，调用标记是这些签名描述符的泛化。

### 定义调用标记

在某个模块的头部部分的某个地方，模块将以`call_tag.new $ct1 : [i32] -> [i32]`的方式声明调用标记。
此声明建立了一个新的调用标记`$ct1`，它仅能被当前模块调用(除非它被导出了)，且它的签名为`[i32] -> [i32]`。
该模块还可以声明调用标记，如`call_tag.canon $ct2 : [i32] -> [i32]`，它给签名`[i32] -> [i32]`定义了标准的调用标记`$ct2`。
标准的调用标记能被所有模块访问，且由签名唯一确定。
(通过历史注释了解以下评论: `call_tag.canon`原名为`call_tag.get`。)

### 关联调用标记

当模块定义函数时，可以指定与它关联的`funcref`能够接受的调用标记。
(默认地，`dispatch.canon`在签名上的返回值是关联的，以达到后向兼容。)
因此，如果一个模块不希望函数隐式地间接调用，那么它可以显式地指定不标记；
又或者指定一些`new`标记，如果它只想用模块自己的标记间接调用它；
又或者指定多个标记，如果它想混合和匹配调度约定。
当然，这些被关联调用标记必须与函数签名适配。

### 通过调用标记调用

`call_indirect`有一个变体，比如`call_funcref $ct`，它指定要使用的调用标记`$ct`。
如果调用标记`$ct`有关联的签名类型`[t1*] -> [t2*]`，那么`call_funcref $ct`有类型`[t1* funcref] -> [t2*]`。
因此，提供的输入和期望的输出被类型检查以匹配与调用标记相关联的签名。
当前的`call_indirect`变成了一种缩写， 用于首先从适当的表中获取`funcref`，
然后使用`call_funcref`，`$ct`为通过`call_tag.canon`从期望的签名中得到的调用标记的结果。

当`$ct`是函数指定的调用标签时，给定了`funcref`的`call_funcref $ct`的执行会成功。
所以当函数指定了一个调用标签时，就会在运行时两个标签间完成一个简易的按位相等性检查。
如果找到了匹配，这*意味着*参数是函数的有效输入，返回值是函数的可接受输出。
但是，通过显式的调用标签，输入和输出的兼容性*并不意味着*调用将成功，因为调用标记可能（有意地）不匹配，即使它们具有相同的签名。

## 应用程序

### 安全

为了说明这对WebAssembly有用，这里假设我是一个安全意识很强的应用程序。
我对程序的所有入口都非常清楚。 
`call_indirect`是一个意外的入口。
我可以尝试对函数引用的泄露多加关注，以减轻这个问题。
但是泄露还是会发生的，更好的办法是不去执行这些意外的入口。

一个办法是不让我的任何函数关联任何调用标签。
但是，这意味着我不能在我的函数里使用`call_indirect`，这可能给一堆C/C++程序带来很多麻烦。
所以本提案给我所使用的每一个签名提供了使用`call_tag.new`的选项，并将每个函数与相应的新标记关联。
然后，只要我不显式导出那些调用标记，我就可以确定我是唯一可以使用`call_indirect`调用我的函数的人。
此外，如果我的程序中有可以分离的子组件我甚至可以为每个子组件以更细的粒度创建新标记，以确保一个子组件中的`call_indirect`不能调用另一个子组件。
因此，这项建议使我更容易限制`call_indirect`的范围，无论是从其他模块，还是我自己的模块内。

### 优化

如果一个函数没有关联调用标签，那么它就只能直接调用，这支持很多优化。
甚至是如果一个函数真的有关联调用标签，如果这个标签既不是导入的也不是导出的，那么优化器能够生成只在当前模块实例中使用的函数，再进一步说明这个函数只能通过`call_funcref`带一个关联的调用标签间接调用。
同样地，`call_funcref`如果使用了一个既不是导入的也不是导出的标签时，可以省略掉调用时的模块实例间的切换。

### 子类型

当一个函数指定了关联的调用标签时，调用标签的类型只需和函数签名适配。
这里的适配性能轻易地合并子类型.
换句话说，只要调用标记的输入类型是函数的输入类型的子类型，且函数的输出类型是调用标记的输出类型的子类型，那么使用该调用标记的间接调用是完全正确的。
然后，它支持各种类型的OO语言的表面层特性，其中子类/子接口可以优化方法的签名，以接受更大范围的输入，或者（通常）生成更精确的输出。

### 抽象

上述许多语言都希望模块能够在不导出实现（或者至少是私有字段）的情况下导出类`C`。
调用标签旨在支持这种模式，同时避免[#1343](https://github.com/WebAssembly/design/issues/1343)中所述的问题。其中`call_indirect`可用于公开和直接访问导出抽象类型的模块的具体实现。

[Type Imports](https://github.com/WebAssembly/proposal-type-imports/)提案仍然很年轻，为了便于对话，假设导出是通过（1）指定模块签名，然后（2）指定如何用模块的各种定义实例化签名的各个组件来完成的。
因此，第1部分可能会说有一个类型`C_type`，但没有关于该类型的详细信息，然后第2部分可能会说`C_type`表示`ref (struct i32 i32)`。

在这个设定中，假设模块中定义的某个表面级接口方法`foo`接受一个`C`并返回一个整数。
使用上面的接口方法的实现，该模块将定义一个签名为`[object_impl (ref (struct i32 i32))] -> [i32]`调用标记`$ct_foo_internal`(其中`object_impl`是`this`指针)。
该方法的实现是知道类型`C`的具体实现的，所以才会在调用标签中使用`(ref (struct i32 i32))`.

但是，虽然其他模块允许提供它们自己的对方法`foo`的实现，但是它们不允许知道`C`的实现。
因此在模块导出中，第1部分会指定调用标签为`$ct_foo : [object_impl C_type] -> [i32]`，然后第2部分会通过`$ct_foo_internal`标签实例化。
本质上，这次的实例化是合法的，因为`C_type`是通过`ref (struct i32 i32)`实例化的，而其他模块对`C_type`一无所知。
但是，它们可以在对象通过`$ct_foo`来执行`foo`，且可以提供它们自己的`foo`实现，就像它们可以提供任何其他接口方法一样。

此模式支持跨模块的（受控）间接调用，但以尊重抽象的方式进行。
特别地，不像[#1343](https://github.com/WebAssembly/design/issues/1343)，这种设计可以防止使用间接调用直接访问抽象类型的模块实现或伪造抽象类型的值。
这里只需要遵守一个约束: `call_tag.canon`仅允许仅包含*不可实例化*类型的签名，
例如`i32`，`i64`，`f32`，`f64`，和&mdash;[#1343](https://github.com/WebAssembly/design/issues/1343)&mdash;`externref`。
换句话说，这是个从违反抽象的抽象类型中生成标准调用标记的能力。
(这种观察似乎更广泛地扩展到那些将从类型生成规范值的过程，这些类型的值只有在类型相等时才相等。)

## 扩展

除了*直接*函数，我们让模块定义一系列的*switch* (或者间接?)函数，如下:
```
(func_switch $fr
    (on_call_tag $ct1 $f1)
    (on_call_tag $ct2 $f2)
    ...
    (trap)
)
```
这里定义了一个`funcref`(其索引为`$fr`)，不是一个`func`.
对`$fr`的间接调用检查了运行时提供的调用标记是否（按位）等于`$ct1`，....中的任何一个。
如果`$ctn`匹配，将发生对`$fn`的直接调用(理论上;实践上，这个调用是内联的)。
如果不存在匹配，则间接地调用陷入。
类型检查只是检查每个`$ctn`的签名是否与`$f1`的签名兼容。

给定一个`func_switch`，就就通过`ref.func $fr`生成一个`funcref`。
这看起来很奇怪，因为前面的`ref.func`需要一个`func`id。
这个分割是因为`func`做了两件事: 定义一个直接函数*还有*定义一个`func_switch`，它会在每一个关联的标记上调用该函数。
所以每个`func`id同时也是`func_switch`id，从而符合后向兼容。

## 应用程序 

### 接口

当前，`call_indirect`主要用于无类型(从wasm看来)函数调用。
但是我们可以进一步扩展调用标记的概念来支持更多的语言特性。
特别是，对于具有多个接口继承的语言，接口方法分发中也出现了相同的模式。
接口方法分发是各种流行语言的一个重要特性，且这些特性的性能通常都是通过wasm不依赖的JIT技术实现的。

`func_switch`扩展意味着`funcref`的行为可以取决于使用的特定调用标记(无论是匹配还是陷入)。
通过这个，我们给很多多接口继承的语言做出高效的无JIT的接口方法分发实现(和其他少为人知动态分发模式)。
承上，实现接口方法分派的一种方法是让每个v表都有一个槽数组，并为每个接口方法分配一些槽号。
不幸的是，一个对象有可能实现具有相同槽号的多个接口方法。
因此，当调用接口方法时，除了参数外，调用方将接口方法的标识符（即其调用标记）推送到堆栈上，然后调用匹配槽中的函数。
然后，该函数打开该标识符并重定向到适当的实现，就像是`func_switch`。
详情请参考[Java接口的高效实现: Invokeinterface considered harmless](https://dl.acm.org/doi/10.1145/504282.504291)。

如果没有WebAssembly的直接支持，将很难实现此模式，因为分配给同一插槽的两个接口方法可以具有完全不同的签名，例如，参数的数量和大小。
因此，调用标记支持在实践中使用的重要模式，以支持对许多主要语言至关重要的功能(特别是Java，Kotlin，和 Scala，但是C#不是，因为它决定支持泛型接口的多个实例化继承)。

### 动态Arity

在函数式语言中，类型`a -> b -> c`的值(每个字母都是一个可变的类型)是未知arity的闭包。
因为居里化，它可以是一个期望值为`a`的闭包，然后返回一个期望值为`b`，然后返回`c`的闭包。
因为一等函数，`c`本身可以表示函数类型，所以它可以是一个居里化后的三元闭包。

函数式语言可以实现闭包应用程序，方法是让每个闭包指定它的arity，并让每个调用者这个arity。
又或者函数式语言可以对一个闭包的`funcref`使用`func_switch`，并让每个调用者为手头的arity使用一个call标记，然后使用`func_switch`来提供适当功能。
后者的效率相对较高，但是考虑到函数式语言中函数应用的频率，这种适度的改善可能是值得注意的。

## 前向兼容

初步调查表明，调用标记将与参数化（即泛型）接口、多态函数/方法以及存在类型等特性兼容，以消除多余的类型转换。
